# 助手类库
助手类是代替函数包的一个解决办法
它是把函数进行归类，通过类的静态方法调用
如**file_mkdir**函数按照这种方法归类就是
```php
<?php
class File {
    public static function mkdir($dir){
        # 创建目录
    }
}
```

以后都使用静态方法进行调用
```php
<?php

File::mkdir('/home/linzh/mydir');
```

## 函数不是更简单吗？为什么这么做？

确实通过函数调用更加简单直观，但往往简单直观的会带来效率上的瓶颈

例如一个团队使用ftp进行代码的共享和部署工作，尽管这种方式相当简单相当直观，但随之而来的问题是相当严重的；
再例如使用gtk编写图形界面和swing编写前后立马会让你产生抛弃函数式编程的冲动

对于初学者来说，PHP是一个函数组成面向过程的语言，比较明显的问题是函数功能的分类

例如一个面向过程设计的大型系统使用了5000个函数，即便加了多重前缀，这么多函数还是无法管理

而PHP5.1.2引入的**spl_autoload_register**函数和5.3版本以后引入了命名空间带给我们新的解决思路：
**方法归类，类归命名空间**

#### 方法归类
具体地说就如文件处理相关的函数归到File类中，网络请求相关的函数归类到Network类中，乃至业务层面的订单相关的函数归类到Orders类中等等

按照这样的思路我们可以把5000个函数归结为200多个类，这样相对来说更符合人脑的处理，在加上神奇的**spl_autoload_register**
我们可以免去大量的**include_once**这样的方法

#### 类归命名空间
命名空间可以说是对类的划分，学过Java的同学都见过**package**和**import**，在PHP的世界里对应的是**namespace**和**use**

比如之前提到的5000个函数划分到200个类，感觉还是太多了，那么可以使用命名空间对类惊醒划分

比如前面提到的File和Network类，一个负责磁盘的I/O，一个负责网络的I/O,那么我可以将它们划分到io层面，那么我们可以建立一个文件夹**io**，并把这两个类文件丢进去
类的定义时加上io段
如:
```php
<?php
namespace xxx\io;
class File {
    # 读写文件，创建删除目录方法
}



